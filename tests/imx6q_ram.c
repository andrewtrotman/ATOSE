/*
	IMX6Q_RAM.C
	-----------
	Copyright (c) 2012-2013 Andrew Trotman
	Licensed BSD
*/
#include <stdint.h>
#include <string.h>
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsuart.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsccm.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsiomuxc.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsepit.h"

/*
	Default baud rate is 115200 and we'll talk down UARR-2 as that's the
	console on the SABRE Lite board
*/
#define BAUD_RATE 115200
#define DEFAULT_UART 2		/* can be either 2 (SABRE Lite "console") or 1 (the other UART) */

/*
	PLL3 frequency
*/
#define PLL3_FREQUENCY 80000000

/*
	We'll use timer 1 for delays
*/
#define DEFAULT_TIMER 1

/*
	DEBUG_PUTC()
	------------
*/
void debug_putc(char value)
{
/*
	Write to the serial port
*/
HW_UART_UTXD(DEFAULT_UART).U = value;

/*
	Make sure it was sent
*/
while (HW_UART_UTS(DEFAULT_UART).B.TXEMPTY == 0)
	; // do nothing
}

/*
	DEBUG_PUTS()
	------------
*/
void debug_puts(char *string)
{
while (*string != '\0')
	debug_putc(*string++);
}

/*
	DEBUG_PRINT_HEX()
	-----------------
*/
void debug_print_hex(int data)
{
int i = 0;
char c;

for (i = sizeof(int)*2-1; i >= 0; i--)
	{
	c = data>>(i*4);
	c &= 0xf;
	if (c > 9)
		debug_putc(c-10+'A');
	else
		debug_putc(c+'0');
	}
}


/*
	ENABLE_PINS()
	-------------
	This code was automatically generated by the IOMUX tool and is used to turn on the pads for UART 2
*/
void enable_pins(void)
{
#if (DEFAULT_UART == 1)
	/*
		On the SABRE Lite, UART-1 {the "other" UART) comes out at pins E13 and F13
	*/
	HW_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6_WR(BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6_MUX_MODE_V(ALT1));
	HW_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_WR(BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_SRE_V(SLOW));
	HW_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_DAISY_V(CSI0_DATA10_ALT3));

	HW_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7_WR(BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7_MUX_MODE_V(ALT1));
	HW_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_WR(BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_SRE_V(SLOW));
	HW_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_DAISY_V(CSI0_DATA10_ALT3));
	HW_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_DAISY_V(SD3_DATA6_ALT1));
#elif (DEFAULT_UART == 2)
	/*
		On the SABRE Lite UART-2 (the "console") comes out at pins E24 and E25
	*/
	HW_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA27_WR(BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA27_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA27_MUX_MODE_V(ALT4));
	HW_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_WR(BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_SRE_V(SLOW));
	HW_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_DAISY_V(EIM_DATA26_ALT4));

	HW_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26_WR(BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26_MUX_MODE_V(ALT4));
	HW_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_WR(BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_SRE_V(SLOW));
	HW_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_DAISY_V(EIM_DATA26_ALT4));
	HW_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_DAISY_V(EIM_DATA27_ALT4));
#else
	#error "Only UART 1 and 2 are supported"
#endif
}

/*
	SERIAL_INIT()
	-------------
*/
void serial_init(void)
{
/*
	Disable and soft reset the UART then wait for it to come up
*/
HW_UART_UCR1(DEFAULT_UART).U = 0;						// disable the UART
HW_UART_UCR2(DEFAULT_UART).U = 0;						// software reset (SRST)
while (HW_UART_UCR2(DEFAULT_UART).B.SRST == 0)
	;	// nothing

/*
	Enable the UART
	Enable RXDMUXSEL (must be on)
*/
HW_UART_UCR1(DEFAULT_UART).B.UARTEN = 1;
HW_UART_UCR3(DEFAULT_UART).B.RXDMUXSEL = 1;

/*
	8 bits, 1 stop bit, no parity,software flow control
*/
/*                                8-bits             ignore RTS         enable RX            enable TX         don't reset */
HW_UART_UCR2_WR(DEFAULT_UART, BM_UART_UCR2_WS | BM_UART_UCR2_IRTS | BM_UART_UCR2_RXEN | BM_UART_UCR2_TXEN | BM_UART_UCR2_SRST);

/*
	Set the board rate

	The "Module Clock" is the UART_CLK which comes from CCM.
	The "Peripheral Clock" is the IPG_CLK which comes from CCM.

	PLL3 runs at 80MHz by default
	PLL3 -> CDCDR1:uart_clk_podf (6 bit divider) -> UART_CLK_ROOT
*/

/*
	Divide the clock by 2
*/
HW_UART_UFCR(DEFAULT_UART).B.RFDIV = 0x04;		/* divide input clock by 2 */

/*
	Binary Rate Multiplier Numerator = 0x0F
*/
HW_UART_UBIR(DEFAULT_UART).U = 0x0F;

/*
	Binary Rate Multipier Denominator set based on the baud rate
*/
HW_UART_UBMR(DEFAULT_UART).U = (PLL3_FREQUENCY / (HW_CCM_CSCDR1.B.UART_CLK_PODF + 1)) / (2 * BAUD_RATE);		// UBMR should be 0x015B once set
}

/*
	ENABLE_CLOCKS()
	---------------
*/
void enable_clocks(void)
{
*((uint32_t *)0x020C407C) = 0x0F0000C3;	// CCM Clock Gating Register 5 (CCM_CCGR5) (inc UART clock)
}

/*
	DELAY_INIT()
	------------
*/
void delay_init(void)
{
uint32_t speed_in_Hz[] = {528000000, 396000000, 352000000, 198000000, 594000000};
uint32_t frequency;

HW_CCM_CCGR1.B.CG6 = 0x03;

HW_EPIT_CR_WR(DEFAULT_TIMER, BM_EPIT_CR_SWR);
while ((HW_EPIT_CR(DEFAULT_TIMER).B.SWR) != 0)
	;	// nothing

frequency = speed_in_Hz[HW_CCM_CBCMR.B.PRE_PERIPH_CLK_SEL] / (HW_CCM_CBCDR.B.AHB_PODF + 1) / (HW_CCM_CBCDR.B.IPG_PODF + 1);
HW_EPIT_CR_WR(DEFAULT_TIMER, BF_EPIT_CR_CLKSRC(1) | BF_EPIT_CR_PRESCALAR((frequency / 1000000) - 1) | BM_EPIT_CR_RLD | BM_EPIT_CR_IOVW | BM_EPIT_CR_ENMOD);
}

/*
	DELAY_US()
	----------
*/
void delay_us(uint32_t time_in_us)
{
HW_EPIT_LR_WR(DEFAULT_TIMER, time_in_us);
HW_EPIT_SR_SET(DEFAULT_TIMER, BM_EPIT_SR_OCIF);
HW_EPIT_CR_SET(DEFAULT_TIMER, BM_EPIT_CR_EN);

while (HW_EPIT_SR_RD(DEFAULT_TIMER) == 0)
	;	// nothing (i.e. wait)

HW_EPIT_CR_CLR(DEFAULT_TIMER, BM_EPIT_CR_EN);
}


/*
	CONFIGURE_SABERLITE()
	---------------------
	Do not remove he delay_us(1) statements because if you do the
	initialisation happens too quickly and the RAM will fail!
*/
void configure_saberlite(void)
{
*(uint32_t *)(0x020e05a8) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e05b0) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e0524) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e051c) = 0x00000030; delay_us(1);

*(uint32_t *)(0x020e0518) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e050c) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e05b8) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e05c0) = 0x00000030; delay_us(1);

*(uint32_t *)(0x020e05ac) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e05b4) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0528) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0520) = 0x00020030; delay_us(1);

*(uint32_t *)(0x020e0514) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0510) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e05bc) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e05c4) = 0x00020030; delay_us(1);

*(uint32_t *)(0x020e056c) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0578) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0588) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0594) = 0x00020030; delay_us(1);

*(uint32_t *)(0x020e057c) = 0x00020030; delay_us(1);
*(uint32_t *)(0x020e0590) = 0x00003000; delay_us(1);
*(uint32_t *)(0x020e0598) = 0x00003000; delay_us(1);
*(uint32_t *)(0x020e058c) = 0x00000000; delay_us(1);

*(uint32_t *)(0x020e059c) = 0x00003030; delay_us(1);
*(uint32_t *)(0x020e05a0) = 0x00003030; delay_us(1);
*(uint32_t *)(0x020e0784) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e0788) = 0x00000030; delay_us(1);

*(uint32_t *)(0x020e0794) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e079c) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e07a0) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e07a4) = 0x00000030; delay_us(1);

*(uint32_t *)(0x020e07a8) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e0748) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e074c) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e0750) = 0x00020000; delay_us(1);

*(uint32_t *)(0x020e0758) = 0x00000000; delay_us(1);
*(uint32_t *)(0x020e0774) = 0x00020000; delay_us(1);
*(uint32_t *)(0x020e078c) = 0x00000030; delay_us(1);
*(uint32_t *)(0x020e0798) = 0x000C0000; delay_us(1);

*(uint32_t *)(0x021b081c) = 0x33333333; delay_us(1);
*(uint32_t *)(0x021b0820) = 0x33333333; delay_us(1);
*(uint32_t *)(0x021b0824) = 0x33333333; delay_us(1);
*(uint32_t *)(0x021b0828) = 0x33333333; delay_us(1);

*(uint32_t *)(0x021b481c) = 0x33333333; delay_us(1);
*(uint32_t *)(0x021b4820) = 0x33333333; delay_us(1);
*(uint32_t *)(0x021b4824) = 0x33333333; delay_us(1);
*(uint32_t *)(0x021b4828) = 0x33333333; delay_us(1);

*(uint32_t *)(0x021b0018) = 0x00081740; delay_us(1);

*(uint32_t *)(0x021b001c) = 0x00008000; delay_us(1);
*(uint32_t *)(0x021b000c) = 0x555A7975; delay_us(1);
*(uint32_t *)(0x021b0010) = 0xFF538E64; delay_us(1);
*(uint32_t *)(0x021b0014) = 0x01FF00DB; delay_us(1);
*(uint32_t *)(0x021b002c) = 0x000026D2; delay_us(1);

*(uint32_t *)(0x021b0030) = 0x005B0E21; delay_us(1);
*(uint32_t *)(0x021b0008) = 0x09444040; delay_us(1);
*(uint32_t *)(0x021b0004) = 0x00025576; delay_us(1);
*(uint32_t *)(0x021b0040) = 0x00000027; delay_us(1);
*(uint32_t *)(0x021b0000) = 0x831A0000; delay_us(1);

*(uint32_t *)(0x021b001c) = 0x04088032; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x0408803A; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x00008033; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x0000803B; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x00428031; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x00428039; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x09408030; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x09408038; delay_us(1);

*(uint32_t *)(0x021b001c) = 0x04008040; delay_us(1);
*(uint32_t *)(0x021b001c) = 0x04008048; delay_us(1);
*(uint32_t *)(0x021b0800) = 0xA1380003; delay_us(1);
*(uint32_t *)(0x021b4800) = 0xA1380003; delay_us(1);
*(uint32_t *)(0x021b0020) = 0x00005800; delay_us(1);
*(uint32_t *)(0x021b0818) = 0x00022227; delay_us(1);
*(uint32_t *)(0x021b4818) = 0x00022227; delay_us(1);

*(uint32_t *)(0x021b083c) = 0x434B0350; delay_us(1);
*(uint32_t *)(0x021b0840) = 0x034C0359; delay_us(1);
*(uint32_t *)(0x021b483c) = 0x434B0350; delay_us(1);
*(uint32_t *)(0x021b4840) = 0x03650348; delay_us(1);
*(uint32_t *)(0x021b0848) = 0x4436383B; delay_us(1);
*(uint32_t *)(0x021b4848) = 0x39393341; delay_us(1);
*(uint32_t *)(0x021b0850) = 0x35373933; delay_us(1);
*(uint32_t *)(0x021b4850) = 0x48254A36; delay_us(1);

*(uint32_t *)(0x021b080c) = 0x001F001F; delay_us(1);
*(uint32_t *)(0x021b0810) = 0x001F001F; delay_us(1);

*(uint32_t *)(0x021b480c) = 0x00440044; delay_us(1);
*(uint32_t *)(0x021b4810) = 0x00440044; delay_us(1);

*(uint32_t *)(0x021b08b8) = 0x00000800; delay_us(1);
*(uint32_t *)(0x021b48b8) = 0x00000800; delay_us(1);

*(uint32_t *)(0x021b001c) = 0x00000000; delay_us(1);
*(uint32_t *)(0x021b0404) = 0x00011006; delay_us(1);


*(uint32_t *)(0x020c4068) = 0x00C03F3F; delay_us(1);
*(uint32_t *)(0x020c406c) = 0x0030FC03; delay_us(1);
*(uint32_t *)(0x020c4070) = 0x0FFFC000; delay_us(1);
*(uint32_t *)(0x020c4074) = 0x3FF00000; delay_us(1);
*(uint32_t *)(0x020c4078) = 0x00FFF300; delay_us(1);
*(uint32_t *)(0x020c407c) = 0x0F0000C3; delay_us(1);
*(uint32_t *)(0x020c4080) = 0x000003FF; delay_us(1);


*(uint32_t *)(0x020e0010) = 0xF00000CF; delay_us(1);

*(uint32_t *)(0x020e0018) = 0x007F007F; delay_us(1);
*(uint32_t *)(0x020e001c) = 0x007F007F; delay_us(1);
}

/*
	MAIN()
	------
*/
int main(void)
{
uint32_t byte;
uint64_t megabyte;
volatile uint32_t *address;
enable_clocks();
enable_pins();
serial_init();

delay_init();
configure_saberlite();

debug_puts(__TIME__ "\r\n");

address = (uint32_t *)0x20000000;
debug_puts("First word of RAM: Write...");
*address = 0xFFFFFFFF;
debug_puts("Read...");
if (*address != 0xFFFFFFFF)
	debug_puts("Fail\r\n");
else
	debug_puts("Pass\r\n");

for (megabyte = 0x20000000; megabyte < 0xFFFFFFFF; megabyte += 1024 * 1024)
	{
	address = (uint32_t *)((uint32_t)megabyte);
	debug_puts("Write to page:0x");
	debug_print_hex((uint32_t)address);
	debug_puts("\r\n");
	for (byte = 0; byte < 16; byte++)
		{
		*address = ~(uint32_t)address;
		address++;
		}

	address = (uint32_t *)((uint32_t)megabyte);
	debug_puts("Read from page:0x");
	debug_print_hex((uint32_t)address);
	debug_puts("\r\n");
	for (byte = 0; byte < 16; byte++)
		{
		if (*address != ~(uint32_t)address)
			{
			debug_puts("Fail at:");
			debug_print_hex((uint32_t)address);
			debug_puts(" expected ");
			debug_print_hex(~(uint32_t)address);
			debug_puts(" got ");
			debug_print_hex(*address);
			debug_puts("\r\n");
			debug_puts("This would mean you have 0x");
			debug_print_hex(((uint32_t)address) - 0x10000000);
			debug_puts("bytes of memory (0x");
			debug_print_hex((((uint32_t)address) - 0x10000000) / 1024);
			debug_puts("MB)");
			while (1)
				; /* hang */
			}
		address++;
		}
	}

return 0;
}

