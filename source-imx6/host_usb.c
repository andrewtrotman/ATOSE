/*
	HOST_USB.C
	----------
	Copyright (c) 2012-2013 Andrew Trotman
	Licensed BSD
*/

/*
	We need to tell the i.MX6 SDK that we're using an i.MX6Q
*/
#define CHIP_MX6DQ 1

#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsccm.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsccmanalog.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsiomuxc.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsusbcore.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsusbphy.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsusbanalog.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsgpio.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/irq_numbers.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsepit.h"

#include "atose.h"
#include "host_usb.h"

/*
	=====================================================
	=====================================================
	=====================================================
*/
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsuart.h"

#define DEFAULT_UART 2

/*
	DEBUG_PUTC()
	------------
*/
void debug_putc(char value)
{
HW_UART_UTXD(DEFAULT_UART).U = value;
while (HW_UART_UTS(DEFAULT_UART).B.TXEMPTY == 0)
	; // do nothing
}

/*
	DEBUG_PRINT_HEX()
	-----------------
*/
void debug_print_hex(int data)
{
int i = 0;
char c;

for (i = sizeof(int) * 2 - 1; i >= 0; i--)
	{
	c = data >> (i * 4);
	c &= 0xf;
	if (c > 9)
		debug_putc(c - 10 + 'A');
	else
		debug_putc(c + '0');
	}
}

/*
	DEBUG_PRINT_HEX_BYTE()
	----------------------
*/
void debug_print_hex_byte(uint8_t data)
{
const char *string = "0123456789ABCDEF";

debug_putc(string[(data >> 4) & 0x0F]);
debug_putc(string[data & 0x0F]);
}

/*
	DEBUG_PRINT_STRING()
	--------------------
*/
void debug_print_string(const char *string)
{
while (*string != 0)
	debug_putc(*string++);
}

/*
	DEBUG_PRINT_THIS()
	------------------
*/
void debug_print_this(const char *start, uint32_t hex, const char *end = "")
{
debug_print_string(start);
debug_print_hex(hex);
debug_print_string(end);
debug_print_string("\r\n");
}

/*
	DEBUG_PRINT_CF_THIS()
	---------------------
*/
void debug_print_cf_this(const char *start, uint32_t hex1, uint32_t hex2, const char *end = "")
{
debug_print_string(start);
debug_print_hex(hex1);
debug_print_string(hex1 == hex2 ? "  = " : " != ");
debug_print_hex(hex2);
debug_print_string(end);
debug_print_string("\r\n");
}

/*
	=====================================================
	=====================================================
	=====================================================
*/
#define DEFAULT_TIMER 1

/*
	DELAY_INIT()
	------------
*/
void delay_init(void)
{
uint32_t speed_in_Hz[] = {528000000, 396000000, 352000000, 198000000, 594000000};
uint32_t frequency;

HW_CCM_CCGR1.B.CG6 = 0x03;

HW_EPIT_CR_WR(DEFAULT_TIMER, BM_EPIT_CR_SWR);
while ((HW_EPIT_CR(DEFAULT_TIMER).B.SWR) != 0)
	;	// nothing

frequency = speed_in_Hz[HW_CCM_CBCMR.B.PRE_PERIPH_CLK_SEL] / (HW_CCM_CBCDR.B.AHB_PODF + 1) / (HW_CCM_CBCDR.B.IPG_PODF + 1);
HW_EPIT_CR_WR(DEFAULT_TIMER, BF_EPIT_CR_CLKSRC(1) | BF_EPIT_CR_PRESCALAR((frequency / 1000000) - 1) | BM_EPIT_CR_RLD | BM_EPIT_CR_IOVW | BM_EPIT_CR_ENMOD);
}

/*
	DELAY_US()
	----------
*/
void delay_us(uint32_t time_in_us)
{
HW_EPIT_LR_WR(DEFAULT_TIMER, time_in_us);
HW_EPIT_SR_SET(DEFAULT_TIMER, BM_EPIT_SR_OCIF);
HW_EPIT_CR_SET(DEFAULT_TIMER, BM_EPIT_CR_EN);

while (HW_EPIT_SR_RD(DEFAULT_TIMER) == 0)
	;	// nothing (i.e. wait)

HW_EPIT_CR_CLR(DEFAULT_TIMER, BM_EPIT_CR_EN);
}

/*
	=====================================================
	=====================================================
	=====================================================
*/

// Function to configure IOMUXC for gpio7 module.
void gpio7_iomux_config(void)
{
/*
	Enable the pads (this code was generated by the IOMUX tool)
*/
HW_IOMUXC_SW_MUX_CTL_PAD_GPIO17_WR(
	BF_IOMUXC_SW_MUX_CTL_PAD_GPIO17_SION_V(DISABLED) |
	BF_IOMUXC_SW_MUX_CTL_PAD_GPIO17_MUX_MODE_V(ALT5));

HW_IOMUXC_SW_PAD_CTL_PAD_GPIO17_WR(
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_HYS_V(ENABLED) |
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_PUS_V(100K_OHM_PU) |
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_PUE_V(PULL) |
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_PKE_V(ENABLED) |
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_ODE_V(DISABLED) |
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_DSE_V(40_OHM) |
	BF_IOMUXC_SW_PAD_CTL_PAD_GPIO17_SRE_V(SLOW));

delay_us(1000000);
debug_print_string("HUB Pins Enabled\r\n");
/*
	Set the direction to output
*/
HW_GPIO_GDIR_SET(7, 1 << 12);
delay_us(1000000);
debug_print_string("Direction Set\r\n");
HW_GPIO_DR_SET(7, 1 << 12);
delay_us(1000000);
debug_print_string("Pin high\r\n");
}

/*
	=====================================================
	=====================================================
	=====================================================
*/

/*
	ATOSE_HOST_USB::ATOSE_HOST_USB()
	--------------------------------
*/
ATOSE_host_usb::ATOSE_host_usb() : ATOSE_device_driver()
{
delay_init();
/*
	On the SABRE Lite board GPIO port 7/12 is connected to a USB hub that is held in reset until
	the line is set high.  Here we do that
*/
gpio7_iomux_config();

/*
	USB Core 1 is different from Core 0 because its not an OTG port. It differs from
	Core 2 and 3 because it is UTMI - that is, it has a Phy.  It supports "High Speed / Full Speed / Low Speed operation"
	according to page 5188 of "i.MX 6Dual/6Quad Applications Processor Reference Manual Rev. 0, 11/2012"

	Somewhat confusingly, "USBPHY2 is the PHY interface for USB Host1 controller" (page 5454)  I guess they count
	ports from 0 but Phy from 1.

	Page 5461 states:
		"The register settings in this section are recommended for passing USB certification.
		The following settings lower the J/K levels to certifiable limits:
			HW_USBPHY_TX_TXCAL45DP = 0x0
			HW_USBPHY_TX_TXCAL45DN = 0x0
			HW_USBPHY_TX_D_CAL = 0x7"
*/

/*
	Enable the pads (this code was generated by the IOMUX tool)
*/
HW_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA30_WR(
	BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA30_SION_V(DISABLED) |
	BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA30_MUX_MODE_V(ALT6));
HW_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_WR(
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_HYS_V(ENABLED) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_PUS_V(100K_OHM_PU) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_PUE_V(PULL) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_PKE_V(ENABLED) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_ODE_V(DISABLED) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_SPEED_V(100MHZ) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_DSE_V(40_OHM) |
	BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_SRE_V(SLOW));
HW_IOMUXC_USB_H1_OC_SELECT_INPUT_WR(
	BF_IOMUXC_USB_H1_OC_SELECT_INPUT_DAISY_V(EIM_DATA30_ALT6));

/*
	Send the clock the the Phy
*/
HW_CCM_ANALOG_PLL_USB2_SET(BM_CCM_ANALOG_PLL_USB2_POWER);
HW_CCM_ANALOG_PLL_USB2_SET(BM_CCM_ANALOG_PLL_USB2_EN_USB_CLKS);
while(!(HW_CCM_ANALOG_PLL_USB2_RD() & BM_CCM_ANALOG_PLL_USB2_LOCK))
	;// nothing
HW_CCM_ANALOG_PLL_USB2_CLR(BM_CCM_ANALOG_PLL_USB2_BYPASS);
HW_CCM_ANALOG_PLL_USB2_SET(BM_CCM_ANALOG_PLL_USB2_ENABLE);

/*
	Reset the Phy
*/
HW_USBPHY_CTRL_CLR(HW_USBPHY2, BM_USBPHY_CTRL_SFTRST);
HW_USBPHY_CTRL_CLR(HW_USBPHY2, BM_USBPHY_CTRL_CLKGATE);
HW_USBPHY_PWD_WR(HW_USBPHY2, 0);
HW_USBPHY_CTRL_SET(HW_USBPHY2, BM_USBPHY_CTRL_ENUTMILEVEL2 | BM_USBPHY_CTRL_ENUTMILEVEL3 | BM_USBPHY_CTRL_ENHOSTDISCONDETECT);
//HW_USB_ANALOG_USB2_CHRG_DETECT.B.EN_B = 1;

//HW_USB_ANALOG_USB2_MISC.B.EN_CLK_UTMI = 1;

/*
	To enable the USB data pin contact detector, the user should set the CHK_CONTACT bit
	of the USB1_CHRG_DETECT register to 1 and monitor the PLUG_CONTACT bit
	status of the USB1_CHRG_DETECT_STAT register. If PLUG_CONTACT is 1, then it
	indicates that the data pins have make good contacts, otherwise the user should continue
	to wait until this bit is set.

	According to Table 1, it should be noted that the data pin contact detector only works
	when EN_B=0 and CHK_CHRG_B=1, both bit being of the USB1_CHRG_DETECT
	register.
*/

HW_USB_ANALOG_USB2_CHRG_DETECT_WR(BM_USB_ANALOG_USB2_CHRG_DETECT_CHK_CONTACT | BM_USB_ANALOG_USB2_CHRG_DETECT_CHK_CHRG_B);	// monitor for connect event


//HW_USBC_PORTSC1_WR(core, (HW_USBC_PORTSC1_RD(core) & (~(BF_USBC_UH1_PORTSC1_PTS_1(3) | BF_USBC_UH1_PORTSC1_PTS_2(1)))) | (BF_USBC_UH1_PORTSC1_PTS_1(2)));		// ULPI
//HW_USBC_PORTSC1_WR(core, HW_USBC_PORTSC1_RD(core) & (~(BF_USBC_UH1_PORTSC1_PTS_1(3) | BF_USBC_UH1_PORTSC1_PTS_2(1))));	//UTMI
//HW_USBC_PORTSC1_WR(core, ((HW_USBC_PORTSC1_RD(core)) | (BF_USBC_UH1_PORTSC1_PTS_1(3))) & (~BF_USBC_UH1_PORTSC1_PTS_2(1)));	// SERIAL
delay_us(1000000);

/*
	Dump out the values of the status registers
*/
debug_print_cf_this("[USBPHY_PWD    :", HW_USBPHY_PWD(1).U, HW_USBPHY_PWD(2).U, "]");
debug_print_cf_this("[USBPHY_TX     :", HW_USBPHY_TX(1).U, HW_USBPHY_TX(2).U, "]");
debug_print_cf_this("[USBPHY_RX     :", HW_USBPHY_RX(1).U, HW_USBPHY_RX(2).U, "]");
debug_print_cf_this("[USBPHY_CTRL   :", HW_USBPHY_CTRL(1).U, HW_USBPHY_CTRL(2).U, "]");
debug_print_cf_this("[USBPHY_VERSION:", HW_USBPHY_VERSION(1).U, HW_USBPHY_VERSION(2).U, "]");
debug_print_cf_this("[USBPHY_STATUS :", HW_USBPHY_STATUS(1).U, HW_USBPHY_STATUS(2).U, "]");
debug_print_cf_this("[USB_ANALOG_USB_VBUS_DETECT     :", HW_USB_ANALOG_USB1_VBUS_DETECT.U, HW_USB_ANALOG_USB2_VBUS_DETECT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_CHRG_DETECT     :", HW_USB_ANALOG_USB1_CHRG_DETECT.U, HW_USB_ANALOG_USB2_CHRG_DETECT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_VBUS_DETECT_STAT:", HW_USB_ANALOG_USB1_VBUS_DETECT_STAT.U, HW_USB_ANALOG_USB2_VBUS_DETECT_STAT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_CHRG_DETECT_STAT:", HW_USB_ANALOG_USB1_CHRG_DETECT_STAT.U, HW_USB_ANALOG_USB2_CHRG_DETECT_STAT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_MISC            :", HW_USB_ANALOG_USB1_MISC.U, HW_USB_ANALOG_USB2_MISC.U, "]");
debug_print_cf_this("[USB_ANALOG_DIGPROG             :", HW_USB_ANALOG_DIGPROG.U, HW_USB_ANALOG_DIGPROG.U, "]");

/*
	Who-knows why, we just gotta do it (according to the docs)
*/
HW_USBPHY_TX(2).B.TXCAL45DP = 0x00;
HW_USBPHY_TX(2).B.TXCAL45DN = 0x00;
HW_USBPHY_TX(2).B.D_CAL = 0x07;


#ifdef NEVER
uint32_t core = 1;

//! Reset controller after switching PHY's
HW_USBC_USBCMD_WR(core, HW_USBC_USBCMD_RD(core) | BM_USBC_UH1_USBCMD_RST);
while (HW_USBC_USBCMD_RD(core) & BM_USBC_UH1_USBCMD_RST)
	;	// nothing

//! set controller to host mode
HW_USBC_USBMODE_WR(core, USB_USBMODE_CM_HOST);

//! Set Asynchronous schedule park mode to 3
//! to allow up to 3 successive transactions same queue.
//! set interrupt interval to 0 for immediate interrupt
HW_USBC_USBCMD_WR(core, BF_USBC_UH1_USBCMD_ASP(3) | BF_USBC_UH1_USBCMD_ITC(0));

#ifdef USB_USE_INT
    /* setup interrupt */
    usb_init_host_interrupts(port->moduleBaseAddress);
#endif

//! start the controller
//! the controller will start running but the schedules are not yet enabled.
HW_USBC_USBCMD_WR(core, HW_USBC_USBCMD_RD(core) | BM_USBC_UH1_USBCMD_RS);

//! Enable port power.
//! Port power must be set for port to detect a device connection
HW_USBC_PORTSC1_WR(core, HW_USBC_PORTSC1_RD(core) | BM_USBC_UH1_PORTSC1_PP);

//! Enable Vbus power when Vbus power is controlled by GPIO
//! On some board hardware, Vbus is not controlled by PortPower
usbEnableVbus(port);

#endif

/*
	CONFIGURATION OF THE USB PORT ITSELF
*/
/*
	Tell the controller we're a HOST.  Possible values are (see Page 5427)
		00 Idle [Default for combination host/device]
		01 Reserved
		10 Device Controller [Default for device only controller]
		11 Host Controller [Default for host only controller]
*/
HW_USBC_UH1_USBMODE.B.CM = 3;			// HOST mode

#ifdef NEVER
	/*
		Clear all the status bits
	*/
	HW_USBC_UOG_ENDPTSETUPSTAT.U = HW_USBC_UOG_ENDPTSETUPSTAT.U;
	HW_USBC_UOG_ENDPTCOMPLETE.U = HW_USBC_UOG_ENDPTCOMPLETE.U;
	HW_USBC_UOG_ENDPTSTAT.U = HW_USBC_UOG_ENDPTSTAT.U;
#endif

	debug_print_cf_this("[USBPHY_STATUS    :", HW_USBPHY_STATUS(1).U, HW_USBPHY_STATUS(2).U, "]");
	debug_print_this("USBC_UH1_USBSTS   :", HW_USBC_UH1_USBSTS.U);
	debug_print_this("USBC_UH1_PORTSC1  :", HW_USBC_UH1_PORTSC1.U);

/*
	We want to know about the following events:
		BM_USBC_UH1_USBSTS_URI |	// USB USB Reset Received
		BM_USBC_UH1_USBSTS_PCI |	// USB Port Change Detect
		BM_USBC_UH1_USBSTS_UI		// USB Interrupt (USBINT)
*/
HW_USBC_UH1_USBSTS_SET(BM_USBC_UH1_USBSTS_URI | BM_USBC_UH1_USBSTS_PCI | BM_USBC_UH1_USBSTS_UI);

/*
	Enable interrupts
	The Port Change Detect interrupt is essential for a disconnect and reconnect while we're powered up.  If
	we don't enable the port connect then we don't get the reset interrupt to tell us we've just connected to
	a host.
*/
HW_USBC_UH1_USBINTR_WR(BM_USBC_UH1_USBINTR_URE | BM_USBC_UH1_USBINTR_PCE | BM_USBC_UH1_USBINTR_UE);

/*
	Set the port speed, options are:
		BV_USBC_UOG_PORTSC1_PSPD__FULL  0		// 12Mb/s
		BV_USBC_UOG_PORTSC1_PSPD__LOW   1		// 1.5Mb/s
		BV_USBC_UOG_PORTSC1_PSPD__HIGH  2		// 480Mb/s
*/
HW_USBC_UH1_PORTSC1.B.PSPD = 2;

/*
	Turn on the trip-wire mechanism for Setup packets
*/
HW_USBC_UH1_USBMODE.B.SLOM = 1;

/*
	now start the USB sub-system
*/
HW_USBC_UH1_USBCMD.B.RS = 1;

debug_print_cf_this("[USB_ANALOG_USB_VBUS_DETECT_STAT:", HW_USB_ANALOG_USB1_VBUS_DETECT_STAT.U, HW_USB_ANALOG_USB2_VBUS_DETECT_STAT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_CHRG_DETECT_STAT:", HW_USB_ANALOG_USB1_CHRG_DETECT_STAT.U, HW_USB_ANALOG_USB2_CHRG_DETECT_STAT.U, "]");
}

/*
	ATOSE_HOST_USB::GET_INTERRUP_ID()
	---------------------------------
*/
uint32_t ATOSE_host_usb::get_interrup_id(void)
{
return IMX_INT_USBOH3_UH1;
}

/*
	ATOSE_HOST_USB::ENABLE()
	------------------------
*/
void ATOSE_host_usb::enable(void)
{
}

/*
	ATOSE_HOST_USB::ACKNOWLEDGE()
	-----------------------------
*/
void ATOSE_host_usb::acknowledge(void)
{
ATOSE_atose::get_ATOSE()->debug << "[ATOSE_HOST_USB::ACKNOWLEDGE]";
}
