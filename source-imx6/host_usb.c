/*
	HOST_USB.C
	----------
	Copyright (c) 2012-2013 Andrew Trotman
	Licensed BSD
*/

/*
	We need to tell the i.MX6 SDK that we're using an i.MX6Q
*/
#define CHIP_MX6DQ 1

#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsccm.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsccmanalog.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsiomuxc.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsusbcore.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsusbphy.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsusbanalog.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/irq_numbers.h"

#include "atose.h"
#include "host_usb.h"

/*
	=====================================================
	=====================================================
	=====================================================
*/
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsuart.h"

#define DEFAULT_UART 2

/*
	DEBUG_PUTC()
	------------
*/
void debug_putc(char value)
{
HW_UART_UTXD(DEFAULT_UART).U = value;
while (HW_UART_UTS(DEFAULT_UART).B.TXEMPTY == 0)
	; // do nothing
}

/*
	DEBUG_PRINT_HEX()
	-----------------
*/
void debug_print_hex(int data)
{
int i = 0;
char c;

for (i = sizeof(int) * 2 - 1; i >= 0; i--)
	{
	c = data >> (i * 4);
	c &= 0xf;
	if (c > 9)
		debug_putc(c - 10 + 'A');
	else
		debug_putc(c + '0');
	}
}

/*
	DEBUG_PRINT_HEX_BYTE()
	----------------------
*/
void debug_print_hex_byte(uint8_t data)
{
const char *string = "0123456789ABCDEF";

debug_putc(string[(data >> 4) & 0x0F]);
debug_putc(string[data & 0x0F]);
}

/*
	DEBUG_PRINT_STRING()
	--------------------
*/
void debug_print_string(const char *string)
{
while (*string != 0)
	debug_putc(*string++);
}

/*
	DEBUG_PRINT_THIS()
	------------------
*/
void debug_print_this(const char *start, uint32_t hex, const char *end = "")
{
debug_print_string(start);
debug_print_hex(hex);
debug_print_string(end);
debug_print_string("\r\n");
}

/*
	DEBUG_PRINT_CF_THIS()
	---------------------
*/
void debug_print_cf_this(const char *start, uint32_t hex1, uint32_t hex2, const char *end = "")
{
debug_print_string(start);
debug_print_hex(hex1);
debug_print_string(hex1 == hex2 ? "  = " : " != ");
debug_print_hex(hex2);
debug_print_string(end);
debug_print_string("\r\n");
}

/*
	=====================================================
	=====================================================
	=====================================================
*/


/*
	ATOSE_HOST_USB::ATOSE_HOST_USB()
	--------------------------------
*/
ATOSE_host_usb::ATOSE_host_usb() : ATOSE_device_driver()
{
/*
	USB Core 1 is different from Core 0 because its not an OTG port. It differs from
	Core 2 and 3 because it is UTMI - that is, it has a Phy.  It supports "High Speed / Full Speed / Low Speed operation"
	according to page 5188 of "i.MX 6Dual/6Quad Applications Processor Reference Manual Rev. 0, 11/2012"

	Somewhat confusingly, "USBPHY2 is the PHY interface for USB Host1 controller" (page 5454)  I guess they count
	ports from 0 but Phy from 1.

	Page 5461 states:
		"The register settings in this section are recommended for passing USB certification.
		The following settings lower the J/K levels to certifiable limits:
			HW_USBPHY_TX_TXCAL45DP = 0x0
			HW_USBPHY_TX_TXCAL45DN = 0x0
			HW_USBPHY_TX_D_CAL = 0x7"
*/

/*
	Enable the pads (this code was generated by the IOMUX too.
*/
HW_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA30_WR(BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA30_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA30_MUX_MODE_V(ALT6));
HW_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_WR(BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA30_SRE_V(SLOW));
HW_IOMUXC_USB_H1_OC_SELECT_INPUT_WR(BF_IOMUXC_USB_H1_OC_SELECT_INPUT_DAISY_V(EIM_DATA30_ALT6));

/*
	Send the clock the the Phy
*/
HW_CCM_ANALOG_PLL_USB2.B.EN_USB_CLKS = 1;
HW_CCM_ANALOG_PLL_USB2.B.POWER = 1;
HW_CCM_ANALOG_PLL_USB2.B.ENABLE = 1;
HW_CCM_ANALOG_PLL_USB2.B.BYPASS = 0;

/*
	Reset the Phy
*/
HW_USBPHY_CTRL(2).B.SFTRST = 0;
while (HW_USBPHY_CTRL(2).B.SFTRST != 0)
	;	// nothing

/*
	turn on the clocks to the UTMI
*/
HW_USBPHY_CTRL(2).B.CLKGATE = 0;

/*
	Power-up the Phy
*/
HW_USBPHY_PWD(2).U = 0;		// enable power to the USB

/*
	Dump out the values of the status registers
*/
debug_print_cf_this("[HW_USBPHY_PWD    :", HW_USBPHY_PWD(1).U, HW_USBPHY_PWD(2).U, "]");
debug_print_cf_this("[HW_USBPHY_TX     :", HW_USBPHY_TX(1).U, HW_USBPHY_TX(2).U, "]");
debug_print_cf_this("[HW_USBPHY_RX     :", HW_USBPHY_RX(1).U, HW_USBPHY_RX(2).U, "]");
debug_print_cf_this("[HW_USBPHY_CTRL   :", HW_USBPHY_CTRL(1).U, HW_USBPHY_CTRL(2).U, "]");
debug_print_cf_this("[HW_USBPHY_VERSION:", HW_USBPHY_VERSION(1).U, HW_USBPHY_VERSION(2).U, "]");
debug_print_cf_this("[HW_USBPHY_STATUS :", HW_USBPHY_STATUS(1).U, HW_USBPHY_STATUS(2).U, "]");
debug_print_cf_this("[USB_ANALOG_USB_VBUS_DETECT     :", HW_USB_ANALOG_USB1_VBUS_DETECT.U, HW_USB_ANALOG_USB2_VBUS_DETECT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_CHRG_DETECT     :", HW_USB_ANALOG_USB1_CHRG_DETECT.U, HW_USB_ANALOG_USB2_CHRG_DETECT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_VBUS_DETECT_STAT:", HW_USB_ANALOG_USB1_VBUS_DETECT_STAT.U, HW_USB_ANALOG_USB2_VBUS_DETECT_STAT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_CHRG_DETECT_STAT:", HW_USB_ANALOG_USB1_CHRG_DETECT_STAT.U, HW_USB_ANALOG_USB2_CHRG_DETECT_STAT.U, "]");
debug_print_cf_this("[USB_ANALOG_USB_MISC            :", HW_USB_ANALOG_USB1_MISC.U, HW_USB_ANALOG_USB2_MISC.U, "]");
debug_print_cf_this("[USB_ANALOG_DIGPROG             :", HW_USB_ANALOG_DIGPROG.U, HW_USB_ANALOG_DIGPROG.U, "]");

/*
	Who-knows why, we just gotta do it (according to the docs)
*/
HW_USBPHY_TX(2).B.TXCAL45DP = 0x00;
HW_USBPHY_TX(2).B.TXCAL45DN = 0x00;
HW_USBPHY_TX(2).B.D_CAL = 0x07;




}

/*
	ATOSE_HOST_USB::GET_INTERRUP_ID()
	---------------------------------
*/
uint32_t ATOSE_host_usb::get_interrup_id(void)
{
return IMX_INT_USBOH3_UH1;
}

/*
	ATOSE_HOST_USB::ENABLE()
	------------------------
*/
void ATOSE_host_usb::enable(void)
{
}

/*
	ATOSE_HOST_USB::ACKNOWLEDGE()
	-----------------------------
*/
void ATOSE_host_usb::acknowledge(void)
{
ATOSE_atose::get_ATOSE()->debug << "[ATOSE_HOST_USB::ACKNOWLEDGE]";
}
