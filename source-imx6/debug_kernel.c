/*
	DEBUG_KERNEL.C
	--------------
	Copyright (c) 2012-2013 Andrew Trotman
	Licensed BSD
*/
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsccm.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsiomuxc.h"
#include "../systems/iMX6_Platform_SDK/sdk/include/mx6dq/registers/regsuart.h"

#include <stdint.h>

#define DEFAULT_UART 2
#define BAUD_RATE 115200
#define PLL3_FREQUENCY 80000000

/*
	DEBUG_INIT()
	------------
*/
void debug_init(void)
{
uint32_t port = DEFAULT_UART;
/*
	Enable the clock to the UART
*/
*((uint32_t *)0x020C407C) = 0x0F0000C3;	// CCM Clock Gating Register 5 (CCM_CCGR5) (inc UART clock)

/*
	Disable and soft reset the UART then wait for it to come up
*/
HW_UART_UCR1(port).U = 0;						// disable the UART
HW_UART_UCR2(port).U = 0;						// software reset (SRST)
while (HW_UART_UCR2(port).B.SRST == 0)
	;	// nothing

/*
	Enable the UART
	Enable RXDMUXSEL (must be on)
*/
HW_UART_UCR1(port).B.UARTEN = 1;
HW_UART_UCR3(port).B.RXDMUXSEL = 1;

/*
	8 bits, 1 stop bit, no parity,software flow control
*/
/*                        8-bits             ignore RTS         enable RX            enable TX         don't reset */
HW_UART_UCR2_WR(port, BM_UART_UCR2_WS | BM_UART_UCR2_IRTS | BM_UART_UCR2_RXEN | BM_UART_UCR2_TXEN | BM_UART_UCR2_SRST);

/*
	Set the board rate

	The "Module Clock" is the UART_CLK which comes from CCM.
	The "Peripheral Clock" is the IPG_CLK which comes from CCM.

	PLL3 runs at 80MHz by default
	PLL3 -> CDCDR1:uart_clk_podf (6 bit divider) -> UART_CLK_ROOT
*/

/*
	Divide the clock by 2
*/
HW_UART_UFCR(port).B.RFDIV = 0x04;		/* divide input clock by 2 */

/*
	Binary Rate Multiplier Numerator = 0x0F
*/
HW_UART_UBIR(port).U = 0x0F;

/*
	Binary Rate Multipier Denominator set based on the baud rate
*/
HW_UART_UBMR(port).U = (PLL3_FREQUENCY / (HW_CCM_CSCDR1.B.UART_CLK_PODF + 1)) / (2 * BAUD_RATE);		// UBMR should be 0x015B once set

/*
	Finally, enable the pins
	This code was extracted from code automatically generated by the Freescale IOMUX tool for the i.MX6Q and is
	used to turn on the UART pads (i.e. external pins)
*/
if (port == 1)
	{
	/*
		On the SABRE Lite, UART-1 {the "other" UART) comes out at pins E13 and F13
	*/
	HW_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6_WR(BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6_MUX_MODE_V(ALT1));
	HW_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_WR(BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6_SRE_V(SLOW));
	HW_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_DAISY_V(CSI0_DATA10_ALT3));

	HW_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7_WR(BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7_MUX_MODE_V(ALT1));
	HW_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_WR(BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7_SRE_V(SLOW));
	HW_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_DAISY_V(CSI0_DATA10_ALT3));
	/*
		This fix is necessary to route the incoming signal to the UART
	*/
	HW_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART1_UART_RX_DATA_SELECT_INPUT_DAISY_V(SD3_DATA6_ALT1));
	}
else if (port == 2)
	{
	/*
		On the SABRE Lite UART-2 (the "console") comes out at pins E24 and E25
	*/
	HW_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA27_WR(BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA27_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA27_MUX_MODE_V(ALT4));
	HW_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_WR(BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA27_SRE_V(SLOW));
	HW_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_DAISY_V(EIM_DATA26_ALT4));

	HW_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26_WR(BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26_SION_V(DISABLED) | BF_IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26_MUX_MODE_V(ALT4));
	HW_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_WR(BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_HYS_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_PUS_V(100K_OHM_PU) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_PUE_V(PULL) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_PKE_V(ENABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_ODE_V(DISABLED) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_SPEED_V(100MHZ) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_DSE_V(40_OHM) | BF_IOMUXC_SW_PAD_CTL_PAD_EIM_DATA26_SRE_V(SLOW));
	HW_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_DAISY_V(EIM_DATA26_ALT4));

	/*
		This fix is necessary to route the incoming signal to the UART
	*/
	HW_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_WR(BF_IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT_DAISY_V(EIM_DATA27_ALT4));
	}
else
	{
	/*
		We don't currently support other than UART 1 and UART 2
	*/
	}
}

/*
	DEBUG_PUTC()
	------------
*/
void debug_putc(char value)
{
/*
	wait until the buffer is empty
*/
while (HW_UART_UTS(DEFAULT_UART).B.TXEMPTY == 0)
	; // do nothing

/*
	transmit
*/
HW_UART_UTXD(DEFAULT_UART).U = value;

/*
	make sure it went.  We need to do this before and after in the debug code
	to manage the case where someone reinitialises the uart before it empties.
*/
while (HW_UART_UTS(DEFAULT_UART).B.TXEMPTY == 0)
	; // do nothing
}

/*
	DEBUG_PRINT_HEX()
	-----------------
*/
void debug_print_hex(int data)
{
int i = 0;
char c;

for (i = sizeof(int) * 2 - 1; i >= 0; i--)
	{
	c = data >> (i * 4);
	c &= 0xf;
	if (c > 9)
		debug_putc(c - 10 + 'A');
	else
		debug_putc(c + '0');
	}
}

/*
	DEBUG_PRINT_HEX_BYTE()
	----------------------
*/
void debug_print_hex_byte(uint8_t data)
{
const char *string = "0123456789ABCDEF";

debug_putc(string[(data >> 4) & 0x0F]);
debug_putc(string[data & 0x0F]);
}

/*
	DEBUG_PRINT_STRING()
	--------------------
*/
void debug_print_string(const char *string)
{
while (*string != 0)
	debug_putc(*string++);
}

/*
	DEBUG_PRINT_THIS()
	------------------
*/
void debug_print_this(const char *start, uint32_t hex, const char *end = "")
{
debug_print_string(start);
debug_print_hex(hex);
debug_print_string(end);
debug_print_string("\r\n");
}

/*
	DEBUG_PRINT_CF_THIS()
	---------------------
*/
void debug_print_cf_this(const char *start, uint32_t hex1, uint32_t hex2, const char *end = "")
{
debug_print_string(start);
debug_print_hex(hex1);
debug_print_string(hex1 == hex2 ? "  = " : " != ");
debug_print_hex(hex2);
debug_print_string(end);
debug_print_string("\r\n");
}

long isprint(int c)
{
if (c > ' ' && c <= 127)
	return 1;

return 0;
}

/*
	DEBUG_DUMP_BUFFER()
	-------------------
*/
void debug_dump_buffer(unsigned char *buffer, uint32_t address, uint64_t bytes)
{
uint64_t remaining, width, column;

remaining = bytes;
while (remaining > 0)
	{
	debug_print_hex(address);
	debug_print_string(" ");

	width = remaining > 0x10 ? 0x10 : remaining;

	for (column = 0; column < width; column++)
		{
		debug_print_hex_byte(buffer[column]);
		debug_print_string(" ");
		}

	for (; column < 0x10; column++)
		debug_print_string("   ");

	debug_print_string(" ");
	for (column = 0; column < width; column++)
		debug_putc(isprint(buffer[column]) ? buffer[column] : '.');

	debug_print_string("\r\n");
	buffer += width;
	address += width;
	remaining -= width;
	}
}

/*
	DEBUG_PRINT_REGISTERS()
	-----------------------
*/
static uint32_t r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, sp, lr, fp, ip;
static uint32_t *stack;
void debug_print_registers(void)
{
asm volatile
	(
	"mov %0, r0;"
	"mov %1, r1;"
	"mov %2, r2;"
	"mov %3, r3;"
	"mov %4, r4;"
	"mov %5, r5;"
	"mov %6, r6;"
	:"=r"(r0), "=r"(r1), "=r"(r2), "=r"(r3), "=r"(r4), "=r"(r5), "=r"(r6)
	:
	:
	);
asm volatile
	(
	"mov %0, r7;"
	"mov %1, r8;"
	"mov %2, r9;"
	"mov %3, r10;"
	"mov %4, r11;"
	"mov %5, r12;"
	"mov %6, r13;"
	"mov %7, r14;"
	"mov %8, fp;"
	"mov %9, ip;"
	:"=r"(r7), "=r"(r8), "=r"(r9), "=r"(r10), "=r"(r11), "=r"(r12), "=r"(sp), "=r"(lr), "=r"(fp), "=r"(ip)
	:
	:
	);

debug_print_string("\r\nRegisters\r\n");
debug_print_string("R0 :");
debug_print_hex(r0);

debug_print_string(" R1 :");
debug_print_hex(r1);

debug_print_string(" R2 :");
debug_print_hex(r2);

debug_print_string("  R3 :");
debug_print_hex(r3);

debug_print_string("  R4 :");
debug_print_hex(r4);

debug_print_string("  R5 :");
debug_print_hex(r5);

debug_print_string("  R6 :");
debug_print_hex(r6);

debug_print_string("\r\n");

debug_print_string("R7 :");
debug_print_hex(r7);

debug_print_string(" R8 :");
debug_print_hex(r8);

debug_print_string(" R9 :");
debug_print_hex(r9);

debug_print_string(" R10 :");
debug_print_hex(r10);

debug_print_string(" R11 :");
debug_print_hex(r11);

debug_print_string(" R12 :");
debug_print_hex(r12);

debug_print_string("\r\n");

debug_print_string("LR :");
debug_print_hex(lr);

debug_print_string(" SP :");
debug_print_hex(sp);

debug_print_string(" FP :");
debug_print_hex(fp);

debug_print_string(" IP :");
debug_print_hex(ip);

debug_print_string("\r\nStack\r\n");

stack = (uint32_t *)sp;
while (stack < (uint32_t *)(sp + 16 * sizeof(uint32_t)))
	{
	debug_print_hex((uint32_t)stack);
	debug_print_string(" : ");
	debug_print_hex(*stack);
	debug_print_string("\r\n");
	stack++;
	}
}

